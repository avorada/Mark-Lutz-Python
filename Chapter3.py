print(1<2)
print(3.0>4)
print(2.0>=1)
print(2.0!=1)
print(2.0==2)
print(3.0!=3)



a=3
b=8
c=5
print(a<c<b)# проверка на диапозон значения в более короткой форме
print(a<c and c<b)# оже проверка на диапозон значения, но длинее с помощью оператора and
print(c<a<b)
print(a<1.0<c<b)
print(False<3)#False эквивалент нуля
print(1>2.0<3)#первое ложно, поэтому и все  выражение ложно



print(a/b)#истинное деление т.е дробная часть всегда сохраняется, независимо от типа чисел
print(a//b)#деление с округлением вниз, т.е отсекается вся дробная часть и возвращает целое число для целых чисел или вещественное, если хотя б одно число вещественное
print(10/4)
print(10//4)
print(10//4.0)




#для поддержки програмного кода в обеих версиях
print(a//b)#всегда получаем целочисленное число и в 2.х и в 3.х
print(a/float(b))#функция гарантирует получениев вещественного деления в обеих версиях
#from__future__import__division //включает деление (/) как в версиях 3.0 в пайтон 2.6



import math#
print(math.floor(2.5))
print(math.floor(-2.5))#-3
print(math.trunc(2.5))
print(math.trunc(-2.5))#-2 т.е не округляет, а усекает дробную часть
#деление // это округление вниз(т.е к меньшему результату) и в случии отрицательных чисел дает результат как функция floor
print(5/-2)
print(5//-2)
# для 2.6 берем функцию  берем дополнительно float()
print(math.trunc(5/float(-2)))



